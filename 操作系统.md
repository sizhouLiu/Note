# 操作系统

-----

## 第一章、引论

操作系统的主要功能

1. 处理机的管理
2. 储存器的管理
3. 设备管理
4. 文件管理
5. 接口管理

操作系统的特征

1. 并发： 两个或多个事件在同一事件间隔内发生
2. 共享： 系统中的资源可供内存中多个并发执行的进程共同使用
3. 虚拟：把一个物理上的实体变成若干个物理上的对应物
4. 异步：在多道程序的环境下 运行程序走走停停，以不可知的速度向前推进

 操作系统在计算机系统中处于计算机硬件和用户之间的位置

操作系统的基本类型有实时操作系统 批处理操作系统以及分时操作系统

1. 实时操作系统：

   - 优先处理紧急事务，实时性、可靠性

2. 批处理操作系统：

   - 多道批处理并发执行，提高资源利用率

3. 分时操作系统：

   - 允许用户与计算机直接交互

   

## 第二章 、进程的描述与控制

- 进程 ：动态的程序的一次执行过程

[进程创建, 创建原语].
(1)过程:
① 为新进程分配一个唯一的进程标识号,并申请一个空白的 PCB.若 PCB 申请失败,则进程创建失败
②为进程分配运行所需的资源,如内存、文件、I/O设备、CPU 时间等,这些资源或从 Os 获得,或从父进程获得.若资源不足,则处于创建态,等待内存资源③ 初始化 PCB,主要为初始化标志信息、CPU 状态信息、CPU 控制信息,并设置进程的优先级等.④ 若进程就绪队列能接纳新进程,则新进程入队,等待调度.(2)引起进程创建的事件:
① 用户登录,
② 高级调度(作业调度): 从后备队列中选一个作业调入内存,并为其创建进程
③ 提供服务: 如 OS 响应用户请求时,为用户创建一个子进程,④ 应用请求: 如 Unix 系统的 fork() 函数.

进程的组成：

- PCB
  - 进程标识符PID
  - 用户标识符UID、
  - 控制信息
- 程序段：程序的代码
- 数据段：运行时产生的数据

进程的特征：

动态性 并发性 独立性 异步性 结构性 进程的转换

![image-20241128201353080](https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20241128201353080.png)

运行态->就绪态： 时间片到.cpu被其他高优先级的进程抢占

运行态 -> 阻塞态：等待系统资源分配，等待某事发生



进程通信的三种方式

1. 共享储存器机制

2. 消息传递机制

   | 消息头 |
   | ------ |
   | 消息域 |

   发送进程ID

   接受进程ID

3. 管道通信

   - 进程p -> 管道 -> 进程Q

线程

线程是一个基本的cpu的执行单元、也是程序执行流的最小单位

引入线程之后，进程之间可并发，进程内的各线程之间也可以并发

进程是资源分配的基本单位，线程是调度的基本单位

每个线程都有一个线程ID，线程控制块（TCB）

线程也有就绪态 阻塞态 运行态三种基本状态

线程的实现方式

![image-20241128211040539](https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20241128211040539.png)



用户级线程 -->内核级线程

## 第三章 处理机调度与死锁

进程调度方式

非抢占式：

- ​	进程一直执行完，才执行下一个进程

抢占式：

​	有更重要的进程需要处理机时，将处理机分配给重要的进程

调度算法的指标
$$
周转时间 = 完成时间 -到达时间
$$

$$
带权周转时间 =\frac{周转时间}{实际运行时间}
$$

$$
等待时间 = 周转时间- 实际运行时间
$$

调度算法

1.先来先服务（FCFS）

| 进程 | 到达时间 | 运行时间 |
| ---- | -------- | -------- |
| p1   | 0        | 7        |
| p2   | 2        | 4        |
| p3   | 4        | 1        |
| p4   | 5        | 4        |

![image-20241128212035592](https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20241128212035592.png)

2.短作业优先

2.1 非抢占式

![image-20241128212600723](https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20241128212600723.png)

![image-20241128212523461](https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20241128212523461.png)

![image-20241128212759044](https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20241128212759044.png)

### 死锁

各进程互相等待对方手里的资源 导致进程都阻塞无法向前推进的现象

- 死锁产生的必要条件

- 1. 互斥条件 
  2. 不剥夺条件
  3. 请求和保持条件
  4. 循环条件

  死锁的处理策略

1. 预防死锁 破环死锁的四个必要条件中的一个
2. 避免死锁 用某种方式防止进入不安全状态
3. 检测死锁：允许死锁发生 检查出发生后采取措施
4. 接触死锁

处理策略

预防死锁：对资源采用按序分配策略

避免死锁 银行家算法



系统处于安全状态 就一定不会发生死锁

系统处于不安全状态 就可能发生死锁



### 银行家算法

PASS



## 第四章 进程同步

进程同步与进程互斥

- 进程同步：两个或多个进程在它们的工作次序产生的制约关系
- 进程互斥 ： 一个进程访问临界资源时另一个想要访问该资源时必须获得

信号量机制

 wait(s) 原语  P操作

signal(s) 原语  V 操作

记录型信号量

```
/*记录型信号量的定义*/
typedef struct{
int value;//剩余溃源数
struct process *L:1 //等待队列
} semaphore :
```

```
void wait(semaphore s){
	s.value --;
	if(s.value <0)bolck(s.L);
}
```

```
Void sinal(semaphore s
S. value ++ ;
if(s.value<=o)
wakeupl(s.L);
```

S.value ++ 之后<=0,有进程等特该资源

S.valuet++后>0,已没有进程等待

S.value 初值为某资源的数目.

S.yalue=-2,有2个进程在等待

用信号量实现进程互斥、同步1、进程互斥
(互斥信号量mutex,初值为!)在进入区plmutex)--申请资源在退出区vlmutex)--释放没源

## 第五章存储器管理

解决程序大小超过物理内存总和的问题 使用覆盖技术与交还技术

连续分配储存管理方式

1.单一连续分配

​	分为系统区和用户区

系统位于内存的低地址部分

用户区位于内存的地址部分

用户区存放用户进程的数据





①首次适应算法:

找到第一个能满足大小的分区

最佳造应算法:优先使用更小的分区

③最坏适应算法:优先使用更大的空闲区
4 邻近适应莫法:从上次查找结束位置开始查找第一个空闲分区

页号=逻辑地址/页面长度

页内偏移量=逻辑地址%页面长度

物理地址=页面女台址+页内偏移量



![image-20241128220852842](https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20241128220852842.png)

## 第七章输入输出系统

1.先来先服务算法