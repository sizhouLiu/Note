# 深度学习入门

## 感知机 

感知机接受两个输入信号。*x*1、*x*2是输入信号，*y*是输出信号，*w*1、*w*2是权重（*w*是weight的首字母）。图中的○称为“神经元”或者“节点”。输入信号被送往神经元时，会被分别乘以固定的权重（*w*1*x*1、*w*2*x*2）。神经元会计算传送过来的信号的总和，只有当这个总和超过了某个界限值时，才会输出1。这也称为“神经元被激活”。这里将这个界限值称为阈值，用符号*θ*表示。

![image-20231215155935558](C:\Users\sz.L\AppData\Roaming\Typora\typora-user-images\image-20231215155935558.png)

## 神经网络

#### 激活函数

将输入信号总和转换为输出信号的就是激活函数
$$
a* = *b* + *w*1*x*1 + *w*2*x*2

*y* = *h*(*a*)
$$

##### sigmoid函数

![image-20231215160255333](C:\Users\sz.L\AppData\Roaming\Typora\typora-user-images\image-20231215160255333.png)

神经网络中用sigmoid函数作为激活函数，进行信号的转换，转换后的信号被传送给下一个神经元



##### softmax

分类问题中使用的softmax函数可

![image-20231215161608917](C:\Users\sz.L\AppData\Roaming\Typora\typora-user-images\image-20231215161608917.png)

![image-20231215161514935](C:\Users\sz.L\AppData\Roaming\Typora\typora-user-images\image-20231215161514935.png)

#### softmax函数的特征

softmax函数的输出是0*.*0到1*.*0之间的实数输出总和为1是softmax函数的一个重要性质。正因为有了这个性质，我们才可以把softmax函数的输出解释为“概率”。

## 神经网络的学习

#### 神经网络的学习步骤

步骤**1**（**mini-batch**）

从训练数据中随机选择一部分数据。

步骤**2**（计算梯度）

计算损失函数关于各个权重参数的梯度。

步骤**3**（更新参数）

将权重参数沿梯度方向进行微小的更新。

步骤**4**（重复）

重复步骤1、步骤2、步骤3。

神经网路的特征就是线虫数据中学习，也就是由数据去决定各个参数的值，在神经网络中各种参数的值会是成千上万的，在这种情况下，由人工去决定机器的参数是不现实的事情。

手写数字识别是深度学习的一个经典案例，每个人写出来的5都是不同的，那么怎么样才能识别一个字是不是五呢，

从零开始想出一个可以识别5的算法，不如考虑通过有效利用数据来解决这个问题。一种方案是，先从图像中提取特征量再用机器学习技术学习这些特征量的模式。机器学习的方法中，由机器从收集到的数据中找出规律性。与从零开始

想出算法相比，这种方法可以更高效地解决问题，也能减轻人的负担

#### 训练数据和测试数据

我们通过训练数据进行学习，寻找最优的参数；然后，使用测试数据评价训练得到的模型的实际能力。为了正确评价模型的泛化能力，就必须划分训练数据和测试数据。另外，训练数据也可以称为监督数据泛化能力是指处理未被观察过的数据（不包含在训练数据中的数据）的能力。获得泛化能力是机器学习的最终目标。只对某个数据集过度拟合的状态称为过拟合（over fitting）。避免过拟合也是机器学习的一个重要课题

#### 损失函数

神经网络以某个指标为线索寻找最优权重参数。神经网络的学习中所用的指标称为损失函数（loss function）。这个损失函数可以使用任意函数，但一般用均方误差和交叉熵误差等。

##### 均方误差

$$
E = \frac{1}{2} \sum_{k}^{}(yk-tk)^2
$$


$$
yk是表示神经网络的输出，tk表示监督数据，k表示数据的维数
$$

##### 交叉熵误差

交叉熵误差（cross entropy error）也经常被用作损失函数。交叉熵误差如下式所示。

交叉熵是用来评估当前训练得到的**概率分布**与真实分布的差异情况。 它刻画的是实际输出（概率）与期望输出（概率）的距离，也就是交叉熵的值越小，两个概率分布就越接近。
$$
E =  -\sum_{k}^{}t_k\log_{}{y_k}
$$

### 　mini-batch学习

$$
E = -\frac{1}{N}\sum_{n}^{} \sum_{k}^{}t_{nk}\log_{}{y_{nk}}
$$

假设数据有*N*个，N表示第*n*个数据的第*k*个元素的值（$ $是神经网络的输出，tnk是监督数据）



### 偏导数

$$
f(x_0,x_1) = x_0^2+x_1^2
$$

这个函数有两个参数式（4*.*6）有两个变量，所以有必要区分对哪个变量求导数，即对*x*0和*x*1两个变量中的哪一个求导数。另外，我们把这里讨论的有多个变量的函数的导数称为偏导数。用数学式表示的话，可以写成 $\frac{\partial f}{\partial x_0} $、$\frac{\partial y}{\partial x_1} $

### 梯度

像 $\frac{\partial f}{\partial x_0} $、$\frac{\partial y}{\partial x_1} $​这样的由全部变量的偏导数汇总而成的向量称为梯度（gradient）。梯度指示的方向是各点处的函数值减小最多的方向 。

### 梯度法

深度学习需要找到最优参数（权重与偏置），但是损失函数通常非常的繁杂，无法通过人工计算的方式来做优化，于是我们使用梯度下降的方式来减少损失函数

但是梯度下降的方式可能不会达到一个全局最优解 而是陷入一个局部的最优解。虽然梯度的方向并不一定指向最小值，但沿着它的方向能够最大限度地减小函数的值。

此时梯度法就派上用场了。在梯度法中，函数的取值从当前位置沿着梯度方向前进一定距离，然后在新的地方重新求梯度，再沿着新梯度方向前进，如此反复，不断地沿梯度方向前进。像这样，通过不断地沿梯度方向前进，逐渐减小函数值的过程就是梯度法（gradient method）。梯度法是解决机器学习中最优化问题的常用方法，特别是在神经网络的学习中经常被使用。
$$
x_0 =x_0-\eta\frac{\partial f}{\partial x_1}
$$

$$
x_1 =x_1-\eta\frac{\partial f}{\partial x_1}
$$

*η*表示更新量，在神经网络的学习中，称为学习率（learning rate）。学习率决定在一次学习中，应该学习多少，以及在多大程度上更新参数。

### 随机梯度下降法（stochastic gradient descent）

“随机”指的是“随机选择的”的意思，因此，随机梯度下降法是“对随机选择的数据进行的梯度下降法

## 误差反向传播法

### 链式法则

如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示(其实就是从里向外一层一层算)

#### 反向传播法

相反与正向传播 反向传播是乘以对应节点的导数

以$z = x + y$为例其导数分别为
$$
\frac{\partial z}{\partial x}=1
$$

$$
\frac{\partial z}{\partial y}=1
$$

因此加法节点的反向传播只是将输入信号输出到下一个节点

##### 乘法节点的反向传播

以$z=xy$为例
$$
\frac{\partial z}{\partial x}=y
$$

$$
\frac{\partial z}{\partial y}=x
$$

乘法的反向传播会将上游的值乘以正向传播时的输入信号的“翻转值”后传递给下游。

## 



确认数值微分求出的梯度结果和误差反向传播法求出的结果是否一致（严格地讲，是非常相近）的操作称为梯度确认（gradient check）

## 与学习相关的技巧

#### 参数的更新

神经网络的学习的目的是找到使损失函数的值尽可能小的参数。这是寻找最优参数的问题，解决这个问题的过程称为最优化（optimization）。

#### SGD

#### Momentum

和前面的SGD一样，**W**表示要更新的权重参数， 表示损失函数关于**W**的梯度，*η*表示学习率。这里新出现了一个变量**v**，对应物理上的速度。

#### AdaGrad

学习率作为一种超参数十分重要在关于学习率的有效技巧中，有一种被称为学习率衰减（learning rate decay）的方法，即随着学习的进行，使学习率逐渐减小。

AdaGrad会为参数的每个元素适当地调整学习率，

AdaGrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。

#### 权重的初始值

在神经网络的学习中，权重的初始值特别重要。设定什么样的权重初始值，经常关系到神经网络的学习能否成功。

如果想减小权重的值，一开始就将初始值设为较小的值才是正途



数据分布造成反向传播中梯度的值不断变小，最后消失。这个问题称为梯度消失（gradient vanishing）

Xavier初始值

如果前一层的节点数为*n*，则初始值使用标准差为 $\frac{1}{\sqrt{n}}$的分布

##### ReLU的权重初始值

Xavier初始值是以激活函数是线性函数为前提而推导出来的。因为sigmoid函数和tanh函数左右对称，且中央附近可以视作线性函数，所以适合使用Xavier初始值。但当激活函数使用ReLU时，一般推荐使用ReLU专用的初始值，也就是Kaiming He等人推荐的初始值，也称为“He初始值。

当前一层的节点数为*n*时，He初始值使用标准差为 $\sqrt\frac{2}{n}$的高斯分布。当Xavier初始值是$\sqrt\frac{1}{n}$时，（直观上）可以解释为，因为ReLU的负值区域的值为0，为了使它更有广度，所以需要2倍的系数

#### 正则化

机器学习的问题中，过拟合是一个很常见的问题。

发生过拟合的原因，主要有以下两个。

• 模型拥有大量参数、表现力强。

• 训练数据少

#### 权值衰减

权值衰减是一直以来经常被使用的一种抑制过拟合的方法。该方法通过在学习的过程中对大的权重进行惩罚，来抑制过拟合。

#### Dropout

如果网络的模型变得很复杂，只用权值衰减就难以应对了。在这种情况下，我们经常会使用Dropout方法

Dropout是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递，测试时，虽然会传递所有的神经元信号，但是对于各个神经元的输出，要乘上训练时的删除比例后再输出

#### 超参数的验证

超参数是指，比如各层的神经元数量、batch大小、参数更新时的学习率或权值衰减等。如果这些超参数没有设置合适的值，模型的性能就会很差。

##### 验证数据

之前使用的数据集分成了训练数据和测试数据，训练数据用于学习，测试数据用于评估泛化能力。由此，就可以评估是否只过度拟合了训练数据(是否发生了过拟合），以及泛化能力如何等。

如果使用测试数据调整超参数，超参数的值会对测试数据发生过拟合。

所以调整超参数时，必须使用超参数专用的确认数据。用于调整超参数的数据，一般称为验证数据（validation data）。我

#### 超参数的最优化

进行超参数的最优化时，逐渐缩小超参数的“好值”指一开始先大致设定一个范围，从这个范围中随机选出一个超参数（采样），用这个采样到的值进行识别精度的评估；然后，多次重复该操作，观察识别精度的结果，根据这个结果缩小超参数的“好值”的范围。通过重复这一操作，就可以逐渐确定超参数的合适范围。

###### 最优化的步骤：

1. 设定超参数的范围。
2. 从设定的超参数范围中随机采样。
3. 使用步骤1中采样到的超参数的值进行学习，通过验证数据评估识别精度（但是要将epoch设置得很小）。
4. 重复步骤1和步骤2（100次等），根据它们的识别精度的结果，缩小超参数的范围。

## 卷积神经网络（Convolutional Neural Network，**CNN**）

### 整体结构

#### 卷积层

##### 全连接层存在的问题

相邻层的所有神经元之间都有连接，这称为全连接（fully-connected）。

全连接层存在数据的形状被忽视的问题

比如，输入数据是图像时，图像通常是高、长、通道方向上的3维形状。但是，向全连接层输入时，需要将3维数据拉平为1维数据。

图像是3维形状，这个形状中应该含有重要的空间信息。比如，空间上邻近的像素为相似的值、RBG的各个通道之间分别有密切的关联性、相距较远的像素之间没有什么关联等，

而卷积层可以保持形状不变。当输入数据是图像时，卷积层会以3维数据的形式接收输入数据，并同样以3维数据的形式输出至下一层。因此，在CNN中，可以（有可能）正确理解图像等具有形状的数据

CNN 中，有时将卷积层的输入输出数据称为**特征图（feature map）**。其中，卷积层的输入数据称为**输入特征图（input feature map）**，输出数据称为**输出特征图（output feature map）**。

##### 卷积运算

对于输入数据，卷积运算以一定间隔滑动滤波器的窗口并应用。这里所说的窗口是指图7-4中灰色的3 *×* 3的部分。如图7-4所示，将各个位置上卷积核的元素和输入的对应元素相乘，然后再求和（有时将这个计算称为乘积累加运算）。

##### 填充

在进行卷积层的处理之前，有时要向输入数据的周围填入固定的数据（比如0等），这称为填充（padding）

![image-20231227170322471](C:\Users\sz.L\AppData\Roaming\Typora\typora-user-images\image-20231227170322471.png)

卷积运算的填充处理：向输入数据的周围填入**0**（图中用虚线表示填充，并省略了填充的内容“**0**”）

##### 步幅

应用滤波器的位置间隔称为步幅（stride）。

![image-20231227170408400](C:\Users\sz.L\AppData\Roaming\Typora\typora-user-images\image-20231227170408400.png)

这里，假设输入大小为(*H, W*)，滤波器大小为(*FH, FW*)，输出大小为(*OH, OW*)，填充为*P*，步幅为*S*。此时，输出大小可通过式进行计算。
$$
OH = \frac{H+2P-FH}{S}+1
$$

$$
OW = \frac{W+2P-FW}{S}+1
$$

其实就是拿这个公式算长和宽

#### 3维数据的卷积运算

通道方向上有多个特征图时，会按通道

进行输入数据和滤波器的卷积运算，并将结果相加，从而得到输出。

在3维数据的卷积运算中，输入数据和滤波器的通道要设为相同的值。

有多高的数据就要有多少个卷积核

### 批处理

我们希望卷积运算也同样对应批处理。为此，需要将在各层间传递的数

据保存为4维数据。具体地讲，就是按(batch_num*,* channel*,* height*,* width)

的顺序保存数据。

#### 池化层

池化是缩小高、长方向上的空间的运算。

![image-20231227214606929](C:\Users\sz.L\AppData\Roaming\Typora\typora-user-images\image-20231227214606929.png)

就是从多的数据变成少的数据

除了Max池化之外，还有Average池化等，Average池化则是计算目标区域的平均值，在图像识别领域，主要使用Max池化。

##### **池化层的特征**

没有要学习的参数池化层和卷积层不同，没有要学习的参数。池化只是从目标区域中取最大值（或者平均值），所以不存在要学习的参数。

通道数不发生变化

经过池化运算，输入数据和输出数据的通道数不会发生变化。

计算是按通道独立进行的对微小的位置变化具有鲁棒性（健壮）

输入数据发生微小偏差时，池化仍会返回相同的结果。因此，池化对输入数据的微小偏差具有鲁棒性。比如，3 *×* 3的池化的情况下，如图池化会吸收输入数据的偏差（根据数据的不同，结果有可能不一致）

-  CNN在此前的全连接层的网络中新增了卷积层和池化层。
- 使用im2col函数可以简单、高效地实现卷积层和池化层。

# 深度学习

深度学习是加深了层的深度神经网络。

## Data Augmentation

Data Augmentation是基于算法“人为地”扩充输入图像（训练图像），比如说对于输入图像，通过施加旋转、垂直或水平方向上的移动等微小变化，增加图像的数量。这在数据集的图像数量有限时尤其有效。Data Augmentation还可以通过其他各种方法扩充图像，比如裁剪图像的“crop处理”、将图像左右翻转的“flip处理”A 等。对于一般的图像，施加亮度等外观上的变化、放大缩小等尺度上的变化也是有效的。不管怎样，通过Data Augmentation巧妙地增加训练图像，就可以提高深度学习的识别精度。虽然这个看上去只是一个简单的技巧，不过经常会有很好的效果。

## 加深层的好处

可以减少网络的参数数量。加深了层的网络可以用更少的参数达到同等水平（或者更强）的表现力。一次5 *×* 5的卷积运算的区域可以由两次3 *×* 3的卷积运算抵充。并且，相对于前者的参数数量25（5 *×* 5），后者一共是18（2 *×* 3 *×* 3）

叠加小型滤波器来加深网络的好处是可以减少参数的数量，扩大感受野（receptive field，给神经元施加变化的某个局部空间区域）。并且，通过叠加层，将 ReLU等激活函数夹在卷积层的中间，进一步提高了网络的表现力。这是因为向网络添加了基于激活函数的“非线性”表现力，通过非线性函数的叠加，可以表现更加复杂的东西。

加深层的另一个好处就是使学习更加高效。与没有加深层的网络相比，通过加深层，可以减少学习数据，从而高效地进行学习。

实践中经常会灵活应用使用ImageNet这个巨大的数据集学习到的权重数据，这称为迁移学习，将学习完的权重（的一部分）复制到其他神经网络，进行再学习（fine tuning）。比如，准备一个和 VGG相同结构的网络，把学习完的权重作为初始值，以新数据集为对象，进行再学习。迁移学习在手头数据集较少时非常有效。

### 基于GPU的高速化

**GPU**计算的目标就是将这种压倒性的计算能力用于各种用途。所谓GPU计算，是指基于GPU进行通用的数值计算的操作。

深度学习中需要进行大量的乘积累加运算（或者大型矩阵的乘积运算）。这种大量的并行运算正是GPU所擅长的（反过来说，CPU比较擅长连续的、复杂的计算）。因此，与使用单个CPU相比，使用GPU进行深度学习的运算可以达到惊人的高速化。深度学习的框架中使用了NVIDIA提供的CUDA这个面向GPU计算的综合开发环境。

### 分布式学习

虽然通过GPU可以实现深度学习运算的高速化，但即便如此，当网络较深时，学习还是需要几天到几周的时间。将深度学习的学习过程扩展开来的想法（也就是分布式学习）就变得重要起来。为了进一步提高深度学习所需的计算的速度，可以考虑在多个GPU或者多台机器上进行分布式计算。现在的深度学习框架中，出现了好几个支持多GPU或者多机器的分布式学习的框架。其中，Google的TensorFlow、微软的CNTK（Computational Network Toolki）在开发过程中高度重视分布式学习。以大型数据中心的低延迟·高吞吐网络作为支撑，基于这些框架的分布式学习呈现出惊人的效果

#### 

在使用CNN进行物体检测的方法中，有一个叫作R-CNN的有名的方法。

![image-20231227223441101](C:\Users\sz.L\AppData\Roaming\Typora\typora-user-images\image-20231227223441101.png)

## 

## Deep Q-Network（强化学习）

让计算机也在摸索试验的过程中自主学习，这称为强化学习（reinforcement learning）,通过计算机与环境的交互不断调整参数.在使用了深度学习的强化学习方法中，有一个叫作Deep Q-Network通称**DQN**。该方法基于被称为Q学习的强化学习算法。

在Q学习中，为了确定最合适的行动，需要确定一个被称为最优行动价值函数的函数。

不需要提供游戏的状态只需要输入图像就能够让计算机学习。这是强化学习的最大特点
