# 2024 - 12 -15 图灵的猫 面经

## 自我介绍：

讲了自己的项目 和之前的实习工作内容

## 拷打：

为什么要使用 celery 不是Kafka 因为 celery是一个Python写的框架 相性比较好 并且项目里面有一个Redis 可以减少一部分工作

用celery的原因是 我们有一个长任务时间开销很大 需要大概两三分钟 长时间未响应会导致连接断开 return timeout errro 所以使用celery去异步执行 避免连接断开

为什么要用redis？

项目部署在K8s上 有部分内容需要同步  





Python 线程池的实现：

这个忘了 反正调multiprocessing.pool然后就行了... 



进程 线程 协程之间有什么区别

进程有自己的一个内存空间 有进程ID 线程是进程的执行单元 同一个进程下的所有线程共享内存 

进程是操作系统中进行资源分配和调度的基本单位，它拥有自己的独立内存空间和系统资源。每个进程都有独立的堆和栈，不与其他进程共享。进程间通信需要通过特定的机制，如管道、消息队列、信号量等。由于进程拥有独立的内存空间，因此其稳定性和安全性相对较高，但同时上下文切换的开销也较大，因为需要保存和恢复整个进程的状态。

线程是进程内的一个执行单元，也是CPU调度和分派的基本单位。与进程不同，线程共亨进程的内存空间，包括堆和全局变量。线程之间通信更加高效，因为它们可以直接读写共享内存。线程的上下文切换开销较小，因为只需要保存和恢复线程的上下文，而不是整个进程的状态。然而，由于多个线程共享内存空间，因此存在数据竞争和线程安全的问题，需要通过同步和互斥机制来解决。

协程。协程是一种用户态的轻量级线程，其调度完全由用户程序控制，而不需要内核的参与。协程拥有自己的寄存器上下文和栈，但与其他协程共享堆内存。协程的切换开销非常小，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换。这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要程序员显式地进行调度和管理，相对于线程和进程来说，其编程模型更为复杂。



Websocket 为什么在你的服务器不支持 你之后调查过吗







讲一下你这个B站爬虫：

我的项目实现了二维码登陆 我逆向了二维码的接口 然后用Qqury去生成二维码 扫码后请求 接口获取Cookies 棉去了去浏览器拿Cookies 的繁琐过程 更加已用

然后做了根据关键词查询视频 获取视频Bv号  然后是获取投稿人的mid 通过mid去找到Up的个人空间 从而在个人空间获取到Up主的全部视频 然后可以去获取评论区的内容 

并且我做了一个类 可以配置一个数据库 将数据整理入库 供之后分析使用



有使用过一些开源的框架吗？

我有一部分内容是在那个整理出的API文档做的 获取个人空间的部分是自己东拼西凑搞出来的





你说你熟悉Kafka 那kafka是怎么实现的 你讲一下

kafka是一个消息队列 他是可以做到一个削峰的作用  然后他会把消息进行分类 每类消息会被分到不同的topic 会根据topic 新增加 队列的数量 消费者根据需求去订阅不同的队列 这样就降低了很多压力 我们可以把队列拆成很多段每一段是一个parttition 每一个消费者去消费一个parttition 

然后Kafka去顺序写磁盘 他的读取效率实际上非常高 并且应用了零拷贝调用的是sendfile 可以不经过CPU拷贝就完成消息的发送 这是他的一个高性能的点



