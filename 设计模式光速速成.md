# 设计模式光速速成



创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

----

在开闭原则的定义中，软件实体可以是一个软件模块、一个由多个类组成的局部结构或一个独立的类开闭原则是指软件实体应尽量在不修改原有代码的情况下进行扩展，面对需求，对程序的改动是增加新代码，不是更改现有代码。

抽象化是开闭原则的关键相对稳定的抽象层 + 灵活的具体层找到系统的可变因素并将其封装起来。设计模式优缺点评价的重要依据，判断基于该模式设计的系统是否具有良好的灵活性和可扩展性。





![image-20241127000359174](C:\Users\sz.L\AppData\Roaming\Typora\typora-user-images\image-20241127000359174.png)

### 里氏代换原则：

### 所有引用基类的地方必须能透明地使用其子类的对象。



在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。

例如我喜欢动物我喜欢狗，反之不一定成立。

在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象替换父类对象。运用时应该将父类设计为抽象类或者接口，让子类继承父类或者实现父接口，并实现父类中的方法。

无需修改原有子类代码。增加新功能可通过增加新的子类实现。

### 依赖倒转原则：

**高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。**

### 接口隔离原则是对接口进行规范：

4层含义接口要尽量小，不臃肿。但是拆分接口时，首先还得满足单一职责。比如业务逻辑上不可分割的。

接口要高内聚。提高接口、类、模块的处理能力，减少对外的交互。

定制服务。系统设计时考虑为访问者（客户端）提供单独的服务。接口的设计是有限度的。

设计粒度越小，系统越灵活。但是也带来结构复杂化，开发难度增加等。把握好“度”。

### 合成复用原则

合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分新对象通过委派调用已有对象的方法达到复用功能的目的复用时要尽量使用组合/聚合关系（关联关系），少用继承

OOP设计中，两种基本方法在不同的环境中复用已有的设计和实现：组合/聚合关系或者继承。

#### 继承复用：

实现简单，易于扩展。破坏系统的封装性；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；只能在有限的环境中使用。（“白箱”复用 ）

#### 组合/聚合复用：

耦合度相对较低，有选择性地调用成员对象的操作；可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。（“黑箱”复用 ）

由于合成/聚合可以将已有对象纳入到新对象中，使之成为新对象的一部分，所以新对象可以调用已有对象的功能。

#### 合成/聚合复用的优点：  

 该复用支持封装；该复用所需的依赖较少；每个新的任务可将焦点集中在一个任务上。

#### 合成/聚合复用的缺点：

### 迪米特法则

迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用

**一个对象应该对其他对象有最少的了解。**

一个类对其他自己需要耦合或者调用的类知道的尽量少，只管调用其方法即可。

应用迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系



引入合理的“第三者”降低现有对象之间的耦合。

专门用于控制界面控件交互的中间类（Mediator）降低界面控件之间的耦合度。

中间类完成控件之间的调用。

增加或删除控件时，只需要修改中间类，原有控件无需修改。中介者模式详细介绍



### 创建型模式（Creational Pattern）

创建型模式（Creational Pattern）是GoF三大类设计模式中最容易理解的一类，在软件开发中应用非常广泛，创建型设计模式将对象的创建过程和对象的使用过程分离，降低了系统的耦合度，使得软件系统更易于扩展。

创建型模式关注对象的创建过程，对类的实例化过程进行了抽象，对用户隐藏了类的实例的创建细节。

用户使用对象时无需关注对象的创建细节，从而降低系统的耦合度，使得设计方案更易于修改和扩展。

外界对于这些对象只需要知道它们共同的接口，而不用清楚其实现细节，使得整个系统的设计更加符合单一职责原则。软件的结构也更为清晰。

### 简单工厂

#### 简单工厂模式优点：

实现了对象创建和使用的分离

客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可

通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性

#### 简单工厂模式缺点：

工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响

增加系统中类的个数，增加了系统的复杂度和理解难度

系统扩展困难，一旦添加新产品不得不修改工厂逻辑

由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构，工厂类不能得到很好地扩展

#### 简单工厂模式适用环境：

工厂类负责创建的对象比较少，由于创建对象比较少，不会造成工厂方法中的逻辑太过复杂。

客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至于连类名都不需要记住，只需要知道类型所对应的参数即可。

### 工厂方法模式(Factory Method Pattern)  

工厂方法模式(Factory Method Pattern)  简称工厂模式也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。

在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

**模式分析**

 工厂方法模式是简单工厂模式的迚一步抽象和推广

 工厂方法模式保持了简单工厂模式的优点，并克服了它的缺点

 核心的工厂类丌再负责所有产品的创建，而是将具体创建工作交给其子类去完成

 可以允许系统在丌修改工厂角色的情况下引迚新产品

 增加具体产品-->增加具体工厂，符合“开闭原则

**工厂方法模式优点：**

 工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节

 能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部

 在系统中加入新产品时，完全符合开闭原则

**工厂方法模式缺点：**

 系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销

 增加了系统的抽象性和理解难度

**在以下情况下可以使用工厂方法模式：**

 客户端丌知道它所需要的对象的类（客户端需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体产品对象由具体工厂类创建）

 抽象工厂类通过其子类来指定创建哪个对象

### 抽象工厂模式(Abstract Factory Pattern)：

提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。

#### 抽象工厂模式优点：

隔离了具体类的生成，使得客户端并不需要知道什么被创建当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象增加新的产品族很方便，无须修改已有系统，符合开闭原则

####  抽象工厂模式缺点：

增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则

#### 在以下情况下可以使用抽象工厂模式：

一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节系统中有多于一个的产品族，但每次只使用其中某一产品族属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构

### 建造者模式（Builder Pattern）

是最复杂的创建型模式，它用于创建一个包含多个组成部分的复杂对象，可以返回一个完整的产品对象给用户。它通过将客户端与包含多个组成部分的复杂对象的创建过程分离，使得客户端无需知道复杂对象的内部组成部分与装配方式，只需要知道建造者的类型即可。它关注如何一步一步创建一个复杂对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，增加新的建造者非常方便，系统具有较好的扩展性。

建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

将客户端与包含多个部件的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需要知道所需建造者的类型即可

关注如何逐步创建一个复杂的对象，不同的建造者定义了不同的创建过程

客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，扩展方便，符合开闭原则可以更加精细地控制产品的创建过程



### 原型模式（Prototype Pattern）

结构较为简单，它是一种特殊的创建型模式，当需要创建大量相同或者相似对象时，可以通过对一个已有对象的复制获取更多对象。Java语言提供了较为简单的原型模式解决方案，只需要创建一个原型对象，然后通过在类中定义的克隆方法复制自己。该模式应用较为广泛，可以快速生成大量的相似对象，极大提高了创建新实例的效率。

工作原理：将一个原型对象传给要发动创建的对象（即客户端对象），这个要发动创建的对象通过请求原型对象复制自己来实现创建过程

创建新对象（也称为克隆对象）的工厂就是原型类自身，工厂方法由负责复制原型对象的克隆方法来实现



通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，每一个克隆对象都是独立的通过不同的方式对克隆对象进行修改以后，可以得到一系列相似但不完全相同的对象

所有的Java类都继承自java.lang.Object，而Object类提供一个clone()方法，可以将一个Java对象复制一份在Java中可以直接使用Object提供的clone()方法来实现对象的克隆（浅克隆）能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持复制如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常

![image-20241127215657341](https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20241127215657341.png)

#### 原型模式优点：

简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率扩展性较好简化创建结构，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品可以使用深克隆的方式保存对象的状态，以便在需要的时候使用，可辅助实现撤销操作

#### 原型模式缺点：

需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则。在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。



原型管理器(Prototype Manager)将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。

原型管理器中针对抽象类型编程，以便扩展。

### 单例模式（Singleton Pattern）

单例模式（Singleton Pattern）是结构最简单的设计模式，它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以确保系统中一个类只有一个实例，且该实例易于被外界访问，从而方便对实例个数的控制并节约系统资源。 

模式动机如何确保一个类只有一个实例并且这个实例易于被访问？

定义一个全局变量可以确保对象随时都可以被访问，但是不能防止实例化多个对象。

（代码实现）更好的办法是让类自身负责创建和保存它的唯一实例，并保证不能创建其他实例，并且提供一个访问该实例的方法。（机制实现）

单例模式(Singleton Pattern)：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

单例模式的要点有三个：某个类只能有一个实例必须自行创建这个实例必须自行向整个系统提供这个实例单例模式是一种对象创建型模式

### 单例模式优点：

提供了对唯一实例的受控访问可以节约系统资源，提高系统的性能允许可变数目的实例（多例类）

### 单例模式缺点：

扩展困难（缺少抽象层）单例类的职责过重。单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中由于自动垃圾回收机制，可能会导致共享的单例对象的状态丢失

### 饿汉式单例类与懒汉式单例类的比较饿汉式单例类：

无须考虑多个线程同时访问的问题；调用速度和反应时间优于懒汉式单例；资源利用效率不及懒汉式单例；

系统加载时间可能会比较长懒汉式单例类：实现了延迟加载；必须处理好多个线程同时访问的问题；需通过双重检查锁定等机制进行控制，将导致系统性能受到一定影响

### 结构型模式（Structural Pattern）

结构型模式（Structural Pattern）的主要目的就是将不同的类和对象组合在一起，形成更大或者更复杂的结构体。该模式并不是简单地将这些类或对象摆放在一起，而是要提供它们之间的关联方式。不同的结构型模式从不同的角度来组合类或对象，它们尽可能满足各种面向对象设计原则的同时为类或对象的组合提供一系列巧妙的解决方案。

结构型设计模式可以描述两种不同的东西：类与类的实例（即对象）。根据这一点，结构型模式可以分为类结构型模式和对象结构型模式。类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关。而对象结构型模式关心类与对象的组合，通过关联关系在一个类中定义另一个类的实例对象，然后通过该对象调用相应的方法。根据合成复用原则，在系统中尽量使用关联关系替代继承关系，因此大部分结构型模式都是对象结构型模式。



### 适配器模式优点：

适配器模式优点将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构增加了类的透明性和复用性，提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用灵活性和扩展性非常好，更换(增加)适配器，符合开闭原则。类适配器模式：由于继承关系，置换一些适配者的方法很方便对象适配器模式：可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类

### 适配器模式缺点：

- ### 类适配器模式：

- (1) 一次最多只能适配一个适配者类，不能同时适配多个适配者

- (2) 适配者类不能为最终类（final）

- (3) 目标抽象类只能为接口，不能为类对象适配器模式：在适配器中置换适配者类的某些方法比较麻烦

在以下情况下可以使用适配器模式：系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作

### 桥接模式（Bridge Pattern）

桥接模式（Bridge Pattern）是一种很实用的结构型模式，如果系统中某个类存在两个独立变化的维度，通过该模式可以将这两个维度分离出来，使得两者可以独立扩展。桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多重继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效地控制了系统中类的个数。 

桥接模式中体现了很多OOP的思想，包括开闭原则、合成复用原则、里氏代换原则、依赖倒转原则等。

桥接模式可以从接口中分离实现功能，设计更具有扩展性。桥接模式减少了子类个数，代码简洁。

重点理解如何将抽象化(Abstraction)和实现化(Implementation)脱耦，使得两者可以独立变化。



将抽象化和实现化之间的耦合解开，或者说是将强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。

桥接模式中的所谓脱耦就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合）而不是继承关系，从而使得两者可以相对独立地变化。

继承是强耦合关系。

#### 桥接模式优点：

分离抽象接口及其实现部分

可以取代多层继承方案，极大地减少了子类的个数

提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，不需要修改原有系统，符合开闭原则



#### 桥接模式缺点：

会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就要针对抽象层进行设计与编程

正确识别出系统中两个独立变化的维度并不是一件容易的事情

### 组合模式（Composite Pattern）

关注那些存在叶子构件和容器构件的结构以及它们的组织形式，叶子构件中不能包含成员对象，而容器构件中可以包含成员对象，这些成员对象可能是叶子构件对象，也可能是容器构件对象。这些对象可以构成一个树形结构，组合模式用面向对象的方式来处理树形结构，它为叶子构件和容器构件提供了一个公共的抽象构件类，客户端可以针对该抽象类进行处理，而无需关心所操作的是哪种类型的对象。由于树形结构在软件开发中广泛存在，所以组合模式也是常用的结构型模式之一。 

组合模式(Composite Pattern)：组合多个对象形成树形结构以表示“部分-整体”的结构层次。

组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性。

对象结构型模式将对象组织到树形结构中，可以用来描述整体与部分的关系

#### 组合模式优点：

可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，让客户端忽略了层次的差异，方便对整个层次结构进行控制客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码增加新的容器构件和叶子构件都很方便，符合开闭原则为树形结构的面向对象实现提供了一种灵活的解决方案

### 组合模式缺点：

设计更加抽象，对象的业务规则如果很复杂，实现组合模式具有较大难度。而且不是所有的方法都与叶子对象子类都有关联。在增加新构件时很难对容器中的构件类型进行限制

### 安全组合模式抽象构件Component

中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法优点是安全对于叶子对象，客户端不可能调用到这些方法缺点是不够透明，客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件使用频率更高

### 外观模式（Facade Pattern）

是一种使用频率非常高的设计模式，它通过引入一个外观角色来简化客户端和子系统之间的操作，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。  外观模式中，外部与一个子系统的通信可以通过一个统一的外观对象进行。外观模式又称为“门面模式”。也是对象结构型模式之一。

一个客户类需要和多个业务类交互，有时候这些需要交互的业务类会作为一个整体出现

引入一个新的外观类(Facade)来负责和多个业务类【子系统(Subsystem)】进行交互，而客户类只需与外观类交互

为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互没有外观类：每个客户类需要和多个子系统之间进行复杂的交互，系统的耦合度将很大

引入外观类：客户类只需要直接与外观类交互，客户类与子系统之间原有的复杂引用关系由外观类来实现，从而降低了系统的耦合度功能



#### 外观模式优点：

它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可一个子系统的修改对其他子系统没有任何影响，而且子系统的内部变化也不会影响到外观对象

#### 外观模式缺点：

不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则





### 代理模式（Proxy Pattern）

是常用的结构型设计模式之一，当直接访问某些对象存在问题时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。根据代理模式使用目的的不同，代理模式又可以分为多种类型，如远程代理、虚拟代理、保护代理等，它们应用与不同的场合，满足用户不同的需求。代理模式是一种对象结构型模式。  



#### 代理模式优点：

能够协调调用者和被调用者，在一定程度上降低了系统的耦合度客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性

####  代理模式缺点：

由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢（例如保护代理）实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂（例如远程代理）

### 命令模式

#### 模式动机

相同的开关可以通过不同的电线来控制不同的电器

开关  <  --  >请求发送者

电灯 <- -> 请求的最终接收者和处理者

开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者

按钮 <- -> 请求发送者

事件处理类 <- -> 请求的最终接收者和处理者

发送者与接收者之间引入了新的命令对象（类似电线），将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法

相同的按钮可以对应不同的事件处理类





将请求发送者和接收者完全解耦

发送者与接收者之间没有直接引用关系

发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求



命令模式(Command Pattern)：将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。

命令模式的本质是对请求进行封装

将请求发送者和接收者完全解耦

使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。

发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求

命令模式的本质是对请求进行封装

一个请求对应于一个命令，将发出命令的责任和执行命令的责任分开



如果需要更换具体命令类，无须修改源代码，只需修改配置文件，完全符合开闭原则

每一个具体命令类对应一个请求的处理者（接收者），通过向请求发送者注入不同的具体命令对象可以使相同的发送者对应不同的接收者，从而实现“将一个请求封装为一个对象，用不同的请求对客户进行参数化”，客户端只需要将具体命令对象作为参数注入请求发送者，无须直接操作请求的接收者



### 命令模式优点：

降低系统的耦合度新的命令可以很容易地加入到系统中，符合开闭原则可以比较容易地设计一个命令队列或宏命令（组合命令）为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案

### 命令模式缺点：

使用命令模式可能会导致某些系统有过多的具体命令类（针对每一个对请求接收者的调用操作都需要设计一个具体命令类）

### 在以下情况下可以使用命令模式：

需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互

需要在不同的时间指定请求、将请求排队和执行请求需要支持命令的撤销(Undo)操作和恢复(Redo)操作需要将一组操作组合在一起形成宏命令



### 迭代器模式

模式动机电视机 <- -> 存储电视频道的集合 <- -> 聚合类(Aggregate Classes)

电视机遥控器<- ->操作电视频道<- ->迭代器(Iterator)

如何访问一个聚合对象中的元素但又不需要暴露它的内部结构，还能提供多种不同的遍历方式<- -> 迭代器模式



#### 聚合对象的两个职责：

存储数据，聚合对象的基本职责

遍历数据，既是可变化的，又是可分离的

将遍历数据的行为从聚合对象中分离出来，封装在迭代器对象中

由迭代器来提供遍历聚合对象内部数据的行为，简化聚合对象的设计，更符合单一职责原则

#### 迭代器模式优点：

支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式

简化了聚合类

由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，符合开闭原则

#### 迭代器模式缺点：

在增加新的聚合类时需要对应地增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性

抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是一件很容易的事情



访问一个聚合对象的内容而无须暴露它的内部表示

需要为一个聚合对象提供多种遍历方式为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口

### 观察者模式

软件系统：一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变，它们之间将产生联动

定义了对象之间一种一对多的依赖关系，让一个对象的改变能够影响其他对象

发生改变的对象称为观察目标，被通知的对象称为观察者

一个观察目标可以对应多个观察者



#### 观察者模式优点：

可以实现表示层和数据逻辑层的分离

在观察目标和观察者之间建立一个抽象的耦合

支持广播通信，简化了一对多系统设计的难度

符合开闭原则，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便



#### 观察者模式缺点：

将所有的观察者都通知到会花费很多时间

如果存在循环依赖时可能导致系统崩溃

没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而只是知道观察目标发生了变化



### 状态模式

![image-20241128122727994](https://stupid-blog-img.oss-cn-beijing.aliyuncs.com/Blog/image-20241128122727994.png)

用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理

#### 状态模式优点：

封装了状态的转换规则，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中

将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为

允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，可以避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起

可让多个环境对象共享一个状态对象，从而减少系统中对象的个数

#### 状态模式缺点：

会增加系统中类和对象的个数，导致系统运行开销增大

结构与实现都较为复杂，如果使用不当将导致程序结构和代码混乱，增加系统设计的难度

对开闭原则的支持并不太好，增加新的状态类需要修改负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需要修改对应类的源代码

对象的行为依赖于它的状态（例如某些属性值），状态的改变将导致行为的变化在代码中包含大量与对象状态有关的条件语句，

这些条件语句的出现会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强

### 策略模式

#### 策略模式优点：

提供了对开闭原则的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为

提供了管理相关的算法族的办法

提供了一种可以替换继承关系的办法

可以避免多重条件选择语句

提供了一种算法的复用机制，不同的环境类可以方便地复用策略类

#### 策略模式缺点：

客户端必须知道所有的策略类，并自行决定使用哪一个策略类将造成系统产生很多具体策略类无法同时在客户端使用多个策略类



#### 在以下情况下可以使用策略模式：

一个系统需要动态地在几种算法中选择一种

避免使用难以维护的多重条件选择语句

不希望客户端知道复杂的、与算法相关的数据结构，提高算法的保密性与安全性

